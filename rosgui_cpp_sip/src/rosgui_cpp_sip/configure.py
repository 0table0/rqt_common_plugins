import os, sys
import roslib
import sipconfig
from PyQt4 import pyqtconfig

if len(sys.argv) != 5:
  print 'usage: %s rosgui-cpp-base-dir build-dir sip-file output_dir' % (sys.argv[0])
  exit(1)

# The base folder of the c++ library, the SIP build folder, the SIP file and the output directory.
rosgui_cpp_base_dir, build_dir, sip_file, output_dir = sys.argv[1:]

# The name of the SIP build file generated by SIP and used by the build system.
build_file = 'pyqtscripting.sbf'

# Get the PyQt configuration information.
config = pyqtconfig.Configuration()

# Get the extra SIP flags needed by the imported qt module.  Note that
# this normally only includes those flags (-x and -t) that relate to SIP's
# versioning system.
qt_sip_flags = config.pyqt_sip_flags

try:
  os.makedirs(build_dir)
except OSError:
  pass

# Run SIP to generate the code.  Note that we tell SIP where to find the qt
# module's specification files using the -I flag.
os.system(' '.join([
  config.sip_bin,
  '-c', build_dir,
  '-b', os.path.join(build_dir, build_file),
  '-I', config.pyqt_sip_dir,
  '-w',
  qt_sip_flags,
  sip_file
]))

# Create the Makefile.  The QtModuleMakefile class provided by the
# pyqtconfig module takes care of all the extra preprocessor, compiler and
# linker flags needed by the Qt library.
makefile = pyqtconfig.QtGuiModuleMakefile(
  dir=build_dir,
  configuration=config,
  build_file=build_file
)

# Add the library we are wrapping.  The name doesn't include any platform
# specific prefixes or extensions (e.g. the 'lib' prefix on UNIX, or the
# '.dll' extension on Windows).
if not os.environ.has_key('ROS_ROOT'):
    print 'ROS_ROOT was not found in evironment, please setup ROS!'
    exit(1)

makefile.extra_include_dirs.append(os.path.join(rosgui_cpp_base_dir, 'include'))
makefile.extra_include_dirs.append(os.path.join(rosgui_cpp_base_dir, 'src'))

# add some ros packages' include dirs
ros_include_packages = ['roslib', 'rosconsole', 'pluginlib', 'rostime', 'cpp_common', 'tinyxml']

# for ros diamondback add tinyxml
ros_include_packages.append('tinyxml')
makefile.CXXFLAGS.append('-DTIXML_USE_STL')

for package_name in ros_include_packages:
    makefile.extra_include_dirs.append(os.path.join(roslib.packages.get_pkg_dir(package_name), 'include'))

# add rosgui_cpp lib
makefile.extra_lib_dirs.append(os.path.join(rosgui_cpp_base_dir, 'lib'))
makefile.extra_libs.append('rosgui_cpp')
makefile.LFLAGS.append('-Wl,-rpath,' + os.path.join(rosgui_cpp_base_dir, 'lib'))

# Add the library we depend on.
pluginlib_path = roslib.packages.get_pkg_dir('pluginlib')
makefile.LFLAGS.append('-Wl,-rpath,' + os.path.join(pluginlib_path, 'lib'))
makefile.extra_lib_dirs.append(os.path.join(pluginlib_path, 'lib'))
makefile.extra_libs.append('boost_fs_wrapper')
makefile.extra_libs.append('poco_lite')

# redirect location of generated library
makefile._target = os.path.join(output_dir, makefile._target)

# Generate the Makefile itself
makefile.generate()
