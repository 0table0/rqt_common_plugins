import os, sys
import roslib
import sipconfig
from PyQt4 import pyqtconfig

if len(sys.argv) != 4:
  print 'usage: %s base-dir build-dir sip-file' % (sys.argv[0])
  exit(1)

# The name of the project folder, the SIP build folder and the SIP file.
base_dir, build_dir, sip_file = sys.argv[1:]

# The name of the SIP build file generated by SIP and used by the build system.
build_file = "pyqtscripting.sbf"

# Get the PyQt configuration information.
config = pyqtconfig.Configuration()

# Get the extra SIP flags needed by the imported qt module.  Note that
# this normally only includes those flags (-x and -t) that relate to SIP's
# versioning system.
qt_sip_flags = config.pyqt_sip_flags

try:
  os.makedirs(build_dir)
except OSError:
  pass

# Run SIP to generate the code.  Note that we tell SIP where to find the qt
# module's specification files using the -I flag.
print 'sip: building: %s' % (sip_file)
os.system(" ".join([
  config.sip_bin,
  "-c", build_dir,
  "-b", os.path.join(build_dir, build_file),
  "-I", config.pyqt_sip_dir,
  "-w",
  qt_sip_flags,
  sip_file
]))

# Create the Makefile.  The QtModuleMakefile class provided by the
# pyqtconfig module takes care of all the extra preprocessor, compiler and
# linker flags needed by the Qt library.
makefile = pyqtconfig.QtGuiModuleMakefile(
  dir = build_dir,
  configuration = config,
  build_file = build_file
)

# Add the library we are wrapping.  The name doesn't include any platform
# specific prefixes or extensions (e.g. the "lib" prefix on UNIX, or the
# ".dll" extension on Windows).
if not os.environ.has_key('ROS_ROOT'):
    print 'ROS_ROOT was not found in evironment, please setup ROS!'
    exit(1)

makefile.extra_include_dirs.append(os.path.join(base_dir, "include"))
makefile.extra_include_dirs.append(os.path.join(base_dir, "src"))

# for ros
makefile.extra_include_dirs.append(os.path.join(os.environ['ROS_ROOT'], "core/roslib/include"))

# for ros diamondback
makefile.extra_include_dirs.append(os.path.join(os.environ['ROS_ROOT'], "../stacks/common/pluginlib/include"))
makefile.extra_include_dirs.append(os.path.join(os.environ['ROS_ROOT'], "../stacks/ros_comm/tools/rosconsole/include"))
makefile.extra_include_dirs.append(os.path.join(os.environ['ROS_ROOT'], "../stacks/ros_comm/utilities/rostime/include"))
makefile.extra_include_dirs.append(os.path.join(os.environ['ROS_ROOT'], "../stacks/ros_comm/utilities/cpp_common/include"))
makefile.extra_include_dirs.append(os.path.join(os.environ['ROS_ROOT'], "../stacks/common/tinyxml/include"))
makefile.CXXFLAGS.append("-DTIXML_USE_STL")

# for ros >= electric
makefile.extra_include_dirs.append(os.path.join(os.environ['ROS_ROOT'], "../pluginlib/include"))
makefile.extra_include_dirs.append(os.path.join(os.environ['ROS_ROOT'], "../ros_comm/tools/rosconsole/include"))
makefile.extra_include_dirs.append(os.path.join(os.environ['ROS_ROOT'], "../ros_comm/utilities/rostime/include"))
makefile.extra_include_dirs.append(os.path.join(os.environ['ROS_ROOT'], "../ros_comm/utilities/cpp_common/include"))

makefile.extra_lib_dirs.append(os.path.join(base_dir, "lib"))
makefile.extra_libs.append("rosgui_cpp")
makefile.LFLAGS.append("-Wl,-rpath," + os.path.join(base_dir, "lib"))

# Add the library we depend on.
pluginlib_path = roslib.rospack.rospackexec(["find", "pluginlib"])
makefile.LFLAGS.append("-Wl,-rpath," + pluginlib_path + "/lib")
makefile.extra_lib_dirs.append(pluginlib_path + "/lib")
makefile.extra_libs.append("boost_fs_wrapper")
makefile.extra_libs.append("poco_lite")

# Generate the Makefile itself.
makefile.generate()

